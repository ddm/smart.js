#
# ESP8266 Smart.js
#
# SDK: either RTOS or OSS (default)
# GC_DEBUG: if "true" (default) enables string ASN checks
# STACK_GUARD: if "true" (default) enables soft stack guard
# SSL: if set to "Krypton" enables SSL with the krypton lib
#

COMMON_MK_DIR ?= .

include $(COMMON_MK_DIR)/common.mk

SMARTJS_PATH ?= ../..
KRYPTON_PATH ?= ../../../krypton
SMARTJS_SRC ?= $(SMARTJS_PATH)/src
SPIFFS_PATH ?= $(SMARTJS_SRC)/spiffs
SJSJS_PATH ?= $(SMARTJS_SRC)/js
LWIP_PATH ?= lwip
V7_PATH ?= ../../../v7
USE_BOOTLOADER ?=

# Should be RTOS or OSS
SDK := $(shell echo $$SDK_FLAVOUR)
ifndef SDK
$(error Use default Makefile to build project within docker container. To build against locally \
        installed ESP SDK define SDK_FLAVOUR (with RTOS or OSS value) enviroment variable)
endif

BUILD_DIR = $(CURDIR)/build
LWIP_BUILD_DIR = $(BUILD_DIR)/lwip
TOOLS_DIR = tools
COMMON_TOOLS_DIR ?= ../../tools
FW_DIR = firmware
FS_DIR = fs
FS_BUILD_DIR = $(BUILD_DIR)/fs

APP = smartjs
# SSL can be SDK or Krypton
SSL ?= None

APP_MODULES := user $(SPIFFS_PATH)
APP_SRCS := $(notdir $(foreach m,$(APP_MODULES),$(wildcard $(m)/*.c))) \
            sj_prompt.c v7.c sj_v7_ext.c sj_http.c \
            sj_i2c_js.c sj_spi_js.c sj_wifi.c sj_gpio_js.c sj_timers.c \
            sj_adc_js.c mongoose.c sj_mongoose.c sj_mongoose_ws_client.c

JSBIN_SRCS := $(SJSJS_PATH)/clubby.js $(SJSJS_PATH)/sys_rts.js \
              $(SJSJS_PATH)/cloud.js $(SJSJS_PATH)/swupdate.js \
              $(SJSJS_PATH)/MCXXX_LCD.js $(SJSJS_PATH)/I2C.js \
              $(SJSJS_PATH)/demo.js $(SJSJS_PATH)/fileservice.js \
              $(JSBIN_EXTRA)
JS_SRCS    := $(SJSJS_PATH)/smart.js
# In order to keep compatibility
# with shared JS-files, which can call "File.eval(....)"
# using JS as extension
JSBIN_EXT := js
JS_EXT := js
VPATH = $(APP_MODULES) $(SMARTJS_SRC)
IPATH = $(VPATH) $(SDK_PATH)/include $(SDK_PATH)/include/json
LPATH = $(SDK_PATH)/lib $(BUILD_DIR)/lwip/ ./user/

# libraries used in this project, mainly provided by the SDK
APP_LIBS = c gcc hal pp phy net80211 wpa main

# linker script used for the above linkier step
LD_SCRIPT = user/smartjs_no_bootloader.ld

FW_FILE_1_ADDR = 0x00000
FW_FILE_2_ADDR = 0x11000

# spiffs parameters
FW_FS_ADDR = 0x70000
FW_FS_SIZE = 49152

SHIMS = -DNDEBUG

FEATURES = -DV7_BUILD_PROFILE=1 -DV7_ENABLE_FILE \
           -DESP_COREDUMP -DV7_DISABLE_AST_TAG_NAMES -DV7_TEMP_OFF \
           -DV7_ENABLE_COMPACTING_GC -DNO_BSD_SOCKETS -DDISABLE_MD5 \
           -DV7_ENABLE__Math -DV7_ENABLE__Math__max -DV7_ENABLE__Math__min \
           -DV7_ENABLE__Math__random -DV7_ENABLE__Math__round \
           -DV7_ENABLE__Memory__stats -DV7_ENABLE_SPIFFS \
           -DESP_FLASH_BYTES_EMUL -DV7_FORCE_STRICT_MODE \
           -DV7_ENABLE__File__list=1 -DV7_ENABLE__StackTrace=0 \
           -DSPIFFS_ON_PAGE_MOVE_HOOK=esp_spiffs_on_page_move_hook \
           -DCS_MMAP -DV7_MMAP_EXEC \
           -DV7_MMAP_EXEC_ONLY="smart.js_clubby.js_sys_rts.js_MCXXX_LCD.js_I2C.js_cloud.js_demo.js" \
           $(FEATURES_EXTRA)

MONGOOSE_FEATURES = -DMG_DISABLE_MQTT \
                    -DMG_DISABLE_JSON_RPC \
                    -DMG_DISABLE_COAP \
                    -DMG_DISABLE_SYNC_RESOLVER \
                    -DMG_DISABLE_HTTP_DIGEST_AUTH \
                    -DMG_DISABLE_MD5 \
                    -DMG_DISABLE_SOCKETPAIR \
                    -DMG_DISABLE_DAV -DMG_DISABLE_CGI \
                    -DMG_DISABLE_SSI \
                    -DMG_DISABLE_DIRECTORY_LISTING \
                    -DMG_MAX_HTTP_HEADERS=20 \
                    -DMG_MAX_HTTP_REQUEST_SIZE=1024 \
                    -DMG_MAX_PATH=40 \
                    -DMG_MAX_HTTP_SEND_IOBUF=1024 \
                    -DNO_BSD_SOCKETS \
                    -DMG_ESP8266 \
                    -DMG_ENABLE_DEBUG

MEMORY_FLAGS = -DMBUF_SIZE_MULTIPLIER=1 -DFS_MAX_OPEN_FILES=5 \
               -DV7_STACK_SIZE=8192-64

GC_DEBUG ?= true
ifneq "$(GC_DEBUG)" "true"
MEMORY_FLAGS += -DV7_DISABLE_STR_ALLOC_SEQ
endif

STACK_GUARD ?= true
ifeq "$(STACK_GUARD)" "true"
MEMORY_FLAGS += -DV7_STACK_GUARD_MIN_SIZE=256 -finstrument-functions
endif

CFLAGS += -DFS_SIZE=$(FW_FS_SIZE) \
          $(MEMORY_FLAGS) $(SHIMS) $(FEATURES) $(MONGOOSE_FEATURES) \
          $(CFLAGS_EXTRA)

ifneq "$(USE_BOOTLOADER)" "1"
CFLAGS += -DFS_ADDR=$(FW_FS_ADDR)
endif

.PHONY: all clean

ifeq "$(SSL)" "Krypton"
IPATH += $(KRYPTON_PATH)
VPATH += $(KRYPTON_PATH)
APP_SRCS += krypton.c
FEATURES += -DESP_SSL_KRYPTON -DKR_EXT_IO -DKR_EXT_RANDOM -DKR_EXT_MD5 -DKR_EXT_SHA1 -DKRYPTON_DEBUG -DESP_SSL_KRYPTON_DEBUG
endif

ifeq "$(USE_BOOTLOADER)" "1"
APP_SRCS := $(filter-out esp_fs.c,$(APP_SRCS))
endif

ifeq "$(SDK)" "RTOS"
IPATH += $(SDK_PATH)/include/espressif/esp8266 $(SDK_PATH)/include/espressif \
         $(SDK_PATH)/include/lwip $(SDK_PATH)/include/lwip/ipv4 \
         $(SDK_PATH)/include/lwip/ipv6 $(SDK_PATH)/extra_include \
         $(SDK_PATH)/lwip/include/

APP_LIBS += freertos mirom lwip
# -fno-builtin-printf avoid that the compiler "optimizes"
# some printf calls: e.g.
#   printf("foo\n") -> puts("foo")
#   printf("%c", ch) -> <something_that_calls_esp_stuff_not_libc>
CFLAGS += -DRTOS_SDK -DRTOS_TODO -DMG_LWIP -fno-builtin-printf
ifneq "$(NETTEST)" ""
CFLAGS += -DRTOS_NETWORK_TEST
endif
#TODO(alashkin): try to use the same LD script
LD_SCRIPT = user/eagle.app.v6.RTOS.ld
else # OSS SDK
IPATH += lwip/src/include lwip/src/include/ipv4 lwip/espressif/include
APP_LIBS += m lwip_cs
CFLAGS += -DLWIP_OPEN_SRC -DMG_LOCALS -DMG_DISABLE_SOCKET_IF -DESP_ENABLE_MG_LWIP_IF
endif

APP_OBJS = $(patsubst %.c,$(BUILD_DIR)/%.o,$(APP_SRCS))
SRCS = $(APP_SRCS) sj_version.c
OBJS = $(APP_OBJS) $(BUILD_DIR)/sj_version.o
LIBS = $(addprefix -l,$(APP_LIBS))
APP_AR = $(BUILD_DIR)/$(APP).a
APP_OUT = $(BUILD_DIR)/$(APP).out
LWIP_AR = $(LWIP_BUILD_DIR)/liblwip_cs.a
SYMCHECK_OUT = $(BUILD_DIR)/$(APP)_symcheck.out
SYMCHECK_FLAG = $(BUILD_DIR)/$(APP)_symcheck.ok
FW_FILE_1_OUT = $(FW_DIR)/$(FW_FILE_1_ADDR).bin
FW_FILE_2_OUT = $(FW_DIR)/$(FW_FILE_2_ADDR).bin
FW_FILES_OUT = $(FW_FILE_1_OUT) $(FW_FILE_2_OUT)
FW_FS_OUT = $(FW_DIR)/$(FW_FS_ADDR).bin
FS_FILES = $(wildcard $(FS_DIR)/*)

INCDIRS = $(addprefix -I,$(IPATH))
LIBDIRS = $(addprefix -L,$(LPATH))

ESP_TOOL_CMD = 	$(ESPTOOL) elf2image -o $(FW_DIR)/ $(APP_OUT)

ifeq "$(USE_BOOTLOADER)" "1"
PREREQ = rboot
ESPTOOL2     ?= ./build/esptool2
FW_SECTS      = .text .data .rodata
FW_USER_ARGS  = -quiet -bin -boot2
FWs = smartjs smartjs_1 smartjs_2
APP_OUT = $(addprefix $(BUILD_DIR)/, $(addsuffix .out, $(FWs)))
FW_FILES_OUT = $(addprefix $(FW_DIR)/, $(addsuffix .bin, $(FWs)))
ESP_FS_SRC =./user/esp_fs.c
ESP_FS_OBJ = $(BUILD_DIR)/esp_fs.o
BOOT_CFG = ./user/boot.cfg
LDSCRIPT_TEMPL = ./user/smartjs_use_bootloader.ld
FW_FS_OUT = $(FW_DIR)/fs.bin
endif

all: $(FW_DIR) $(BUILD_DIR) $(PREREQ) $(FW_FILES_OUT) $(FW_FS_OUT)
ifeq "$(USE_BOOTLOADER)" "1"
else
	$(Q) rm -f `ls $(FW_DIR)/* \
    | grep -vE '^($(FW_FILE_1_OUT)|$(FW_FILE_2_OUT)|$(FW_FS_OUT))$$'`
endif

$(BUILD_DIR) $(FW_DIR):
	$(Q) mkdir -p $@

# Main output product: firmware files.

$(FW_FILES_OUT): $(APP_OUT)
ifeq "$(USE_BOOTLOADER)" "1"
	$(vecho) "FW $(BUILD_DIR)/$(basename $(notdir $@)).out -> $@"
	$(Q) $(ESPTOOL2) $(FW_USER_ARGS) $(BUILD_DIR)/$(basename $(notdir $@)).out $@ $(FW_SECTS)
else
	$(vecho) "FW $(APP_OUT) -> $(FW_DIR)"
	$(Q) $(ESPTOOL) elf2image -o $(FW_DIR)/ $(APP_OUT)
endif
# -- Linking.

ifeq "$(SDK)" "RTOS"
LDFLAGS += -Wl,--wrap,user_fatal_exception_handler
endif

ifeq "$(USE_BOOTLOADER)" "1"
define compile_fs
$(call compile_params,$(ESP_FS_SRC),$(ESP_FS_OBJ)) -DFS_ADDR=$(FW_FS_ADDR)
$(Q) $(OBJCOPY) --rename-section .rodata=.irom0.text $(ESP_FS_OBJ)
$(Q) $(OBJCOPY) --rename-section .rodata.str1.1=.irom0.text $(ESP_FS_OBJ)
endef
endif

# Link the main ELF output file. Performs symbol clash check beforehand.
$(APP_OUT): $(APP_AR) $(LWIP_AR) $(SYMCHECK_FLAG)
ifeq "$(USE_BOOTLOADER)" "1"
	$(eval FW_FS_ADDR=$(shell cat $(BOOT_CFG)  \
				| grep $(basename $(notdir $@)): | awk -F ':' '{print $$4}'))
	$(eval IROM0ADDR=$(shell cat $(BOOT_CFG)  \
				| grep $(basename $(notdir $@)): | awk -F ':' '{print $$3}'))
	$(Q) sed -e 's/_IROM0ADDR/$(IROM0ADDR)/' $(LDSCRIPT_TEMPL) > $(BUILD_DIR)/smartjs_ls_$(IROM0ADDR).ld
	$(eval LD_SCRIPT=$(BUILD_DIR)/smartjs_ls_$(IROM0ADDR).ld)
	$(vecho) "Linking for IROM0 = $(IROM0ADDR), FS = $(FW_FS_ADDR)"
	$(compile_fs)
	$(link) $(ESP_FS_OBJ)
else
	$(link)
endif


# Symbol check: make sure app doesn't override SDK lib symbols.
# A target is created that uses the same libs but no user code and symbols are
# checked against main app library to make sure there's no overlap.
$(SYMCHECK_FLAG): $(APP_AR) $(SYMCHECK_OUT)
	$(vecho) "SYMCHECK $(SYMCHECK_OUT) vs $(APP_AR)"
	$(Q) python $(TOOLS_DIR)/symcheck.py $(SYMCHECK_OUT) $(APP_AR)
	$(Q) touch $@

$(SYMCHECK_OUT): $(BUILD_DIR)/dummy_main.o
	$(link)

$(BUILD_DIR)/dummy_main.c: $(APP_OBJS)
	$(vecho) "GEN $@"
	$(Q) echo "void user_init(void){}; " \
            "void __wrap_user_fatal_exception_handler(){}; " \
            "void __cyg_profile_func_enter(void *this_fn, void *call_site){};" \
            "void __cyg_profile_func_exit(void *this_fn, void *call_site){}" > $@

# Main app lib.
$(APP_AR): $(OBJS)
	$(vecho) "AR $@"
	$(Q) $(AR) cru $@ $^
# Move strings to flash too, we have the handler.
	$(Q) $(OBJCOPY) --rename-section .rodata=.irom0.text $(APP_AR)
	$(Q) $(OBJCOPY) --rename-section .rodata.str1.1=.irom0.text $(APP_AR)


# LWIP.
$(LWIP_AR): $(LWIP_PATH)
	$(Q) $(MAKE) --no-print-directory -C $(LWIP_PATH) -j3 all BUILD_DIR=$(LWIP_BUILD_DIR)

# This rule is for normal (pre-existing) sources from VPATH.
$(BUILD_DIR)/%.o: %.c
	$(compile)

# This one is for generated sources in build directory.
$(BUILD_DIR)/%.o: $(BUILD_DIR)/%.c
	$(compile)

$(BUILD_DIR)/mongoose.o: mongoose.c
	$(compile) -DEXCLUDE_COMMON

# Generate version. Only regenrates if there are changes in objects.
$(BUILD_DIR)/sj_version.c: $(APP_OBJS)
	$(vecho) "GEN $@"
	@REF=$$(git symbolic-ref HEAD | sed 's:refs/heads/::'); \
	SHA=$$(git rev-parse HEAD | head -c 8); \
	DATE=$$(TZ=GMT date +"%Y%m%d-%H%M%S"); \
	echo "const char *sj_version = \"ESP8266-$$REF/$$DATE/$$SHA\";" > $@

# Pull in auto-generated .c dependencies (if any).
-include $(wildcard $(BUILD_DIR)/*.d)

# -- Filesystem.

$(FS_BUILD_DIR):
	@mkdir -p $(FS_BUILD_DIR)

$(FW_FS_OUT): $(FS_BUILD_DIR) $(FS_FILES) $(JSBIN_SRCS) $(BUILD_DIR)/mkspiffs $(BUILD_DIR)/v7
	/usr/bin/rsync -r --copy-links $(FS_DIR)/ $(FS_BUILD_DIR)/
# OSX virtualbox shared folder have issues with some symlinks. JS_SRCS contains their canonical location
	$(Q) $(foreach js,$(JS_SRCS), \
		echo "CP $(js) -> $(FS_DIR)/$(basename $(notdir $(js))).$(JS_EXT)";\
		cp $(js) $(FS_BUILD_DIR);)
	$(Q) $(foreach jsbin,$(JSBIN_SRCS), \
		echo "V7 $(jsbin) -> $(FS_DIR)/$(basename $(notdir $(jsbin))).$(JSBIN_EXT)";\
		$(BUILD_DIR)/v7 -b $(jsbin) > $(FS_BUILD_DIR)/$(basename $(notdir $(jsbin))).$(JSBIN_EXT);)
	$(vecho) "MKSPIFFS $(FS_DIR) -> $@"
	$(Q) $(BUILD_DIR)/mkspiffs $(FW_FS_SIZE) $(FS_BUILD_DIR) > $@

$(BUILD_DIR)/mkspiffs: $(COMMON_TOOLS_DIR)/mkspiffs.c $(wildcard $(SPIFFS_PATH)/*.c)
	$(vecho) "GCC mkspiffs"
	$(Q) gcc -I. -I$(SPIFFS_PATH) -Iuser -o $@ $^ -DNO_ESP

$(SMARTJS_SRC)/v7.c:
	make -C $(V7_PATH) v7.c
	ln -s ../../v7/v7.c $(SMARTJS_SRC)/v7.c

$(BUILD_DIR)/v7: $(SMARTJS_SRC)/v7.c $(SMARTJS_SRC)/v7.h
	$(vecho) "GCC v7"
	$(Q) gcc -DV7_EXE -DV7_EXPOSE_PRIVATE $(SMARTJS_SRC)/v7.c -lm -o $(BUILD_DIR)/v7
# Target specific warning inhibitions

build/spiffs_hydrogen.o: CFLAGS += -Wno-unused-function

#
# Auxiliary targets.
#

ifeq "$(USE_BOOTLOADER)" "1"
rboot: $(BUILD_DIR)/esptool2 $(BUILD_DIR)/rboot.bin

$(BUILD_DIR)/esptool2:
	echo $(APP_OUT)
	$(MAKE) -C ./bootloader/esptool2

$(BUILD_DIR)/rboot.bin: $(BUILD_DIR)/esptool2
	$(MAKE) -C ./bootloader/rboot
endif

clean:
	$(Q) rm -rf $(BUILD_DIR) $(FW_DIR)

flash: $(FW_OUT) $(FW_FS_OUT)
	$(Q) $(ESPTOOL) --port $(ESPPORT) --baud $(ESPSPEED) write_flash $(ESPFLASHARGS) \
                  $(FW_FILE_1_ADDR) $(FW_FILE_1_OUT) \
                  $(FW_FILE_2_ADDR) $(FW_FILE_2_OUT) \
                  $(FW_FS_ADDR) $(FW_FS_OUT)

flash_no_fs: $(FW_OUT)
	$(Q) $(ESPTOOL) --port $(ESPPORT) --baud $(ESPSPEED) write_flash $(ESPFLASHARGS) \
                  $(FW_FILE_1_ADDR) $(FW_FILE_1_OUT) \
                  $(FW_FILE_2_ADDR) $(FW_FILE_2_OUT)

flash_fs: $(FW_FS_OUT)
	$(Q) $(ESPTOOL) --port $(ESPPORT) --baud $(ESPSPEED) write_flash $(ESPFLASHARGS) \
                  $(FW_FS_ADDR) $(FW_FS_OUT)
